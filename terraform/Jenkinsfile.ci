pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
  }

  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    BACKEND_REPO_NAME  = 'agrivisionops-backend'
    FRONTEND_REPO_NAME = 'agrivisionops-frontend'
    CLUSTER_NAME       = 'agrivisionops-ecs-cluster'
    BACKEND_SERVICE_NAME  = ''
    FRONTEND_SERVICE_NAME = ''
    ECR_URI  = ''
    PUBLIC_URL = ''
  }

  stages {

    stage('Checkout Source') {
      steps {
        echo "üì¶ Cloning repository..."
        checkout scm
        sh 'git rev-parse --short HEAD'
      }
    }

    stage('Fetch Terraform Outputs') {
      steps {
        dir('terraform') {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "üìã Initializing Terraform backend & fetching outputs..."
            script {
              // ‚úÖ Initialize Terraform safely (no infra change)
              sh 'terraform init -input=false -no-color'

              def alb         = sh(script: "terraform output -raw alb_dns_name", returnStdout: true).trim()
              def backendSvc  = sh(script: "terraform output -raw backend_service_name", returnStdout: true).trim()
              def frontendSvc = sh(script: "terraform output -raw frontend_service_name", returnStdout: true).trim()

              env.PUBLIC_URL            = "http://${alb}"
              env.BACKEND_SERVICE_NAME  = backendSvc
              env.FRONTEND_SERVICE_NAME = frontendSvc

              echo "‚úÖ ALB DNS: ${alb}"
              echo "‚úÖ Backend Service: ${backendSvc}"
              echo "‚úÖ Frontend Service: ${frontendSvc}"
            }
          }
        }
      }
    }

stage('AWS ECR Login') {
  steps {
    script {
      withCredentials([
        [$class: 'AmazonWebServicesCredentialsBinding', 
         credentialsId: 'aws-creds', 
         accessKeyVariable: 'AWS_ACCESS_KEY_ID', 
         secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
      ]) {
        echo "üîê Logging into ECR..."

        // üß† Get AWS Account ID (this must now always return your ID)
        def awsAccountId = sh(
          script: "aws sts get-caller-identity --query Account --output text",
          returnStdout: true
        ).trim()

        if (!awsAccountId) {
          error "‚ùå AWS Account ID not found! Check your credentials or IAM permissions."
        }

        env.ECR_URI = "${awsAccountId}.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com"
        echo "‚úÖ ECR URI set to: ${env.ECR_URI}"

        // ü™£ Login securely to ECR
        sh """
          aws ecr get-login-password --region ${env.AWS_DEFAULT_REGION} \
            | docker login --username AWS --password-stdin ${env.ECR_URI}
        """
      }
    }
  }
}

    stage('Build & Tag Docker Images') {
      steps {
        script {
          def tag = "build-${env.BUILD_NUMBER}"
          echo "üöß Building backend & frontend images with tag ${tag}..."
          sh """
            # -------------------- BACKEND --------------------
            docker build -t ${env.BACKEND_REPO_NAME}:${tag} ./app/backend
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:${tag}
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest

            # -------------------- FRONTEND --------------------
            docker build -t ${env.FRONTEND_REPO_NAME}:${tag} ./app/frontend
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:${tag}
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Push Images to ECR') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "‚¨ÜÔ∏è Pushing images to ECR..."
            docker push ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest
            docker push ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Deploy to ECS (Backend & Frontend)') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "üöÄ Updating backend service..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.BACKEND_SERVICE_NAME} \
              --force-new-deployment

            echo "üé® Updating frontend service..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.FRONTEND_SERVICE_NAME} \
              --force-new-deployment
          """
        }
      }
    }

    stage('Verify Deployment') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          echo "üîé Verifying ECS service health..."
          sh """
            aws ecs describe-services --cluster ${env.CLUSTER_NAME} \
              --services ${env.BACKEND_SERVICE_NAME} ${env.FRONTEND_SERVICE_NAME} \
              --query "services[*].{Service:serviceName,Status:status,Running:runningCount,Desired:desiredCount}" \
              --output table
          """
          echo "üåç Application accessible at: ${env.PUBLIC_URL}"
        }
      }
    }
  }

  post {
    success {
      echo "‚úÖ SUCCESS: All ECS services deployed successfully!"
      echo "üåê Access URL ‚Üí ${env.PUBLIC_URL}"
    }
    failure {
      echo "‚ùå FAILURE: Something went wrong. Check build logs carefully!"
    }
    always {
      echo "üßπ Cleaning up local Docker artifacts..."
      sh 'docker system prune -f || true'
    }
  }
}
