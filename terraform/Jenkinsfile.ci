pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    // Disabling concurrent builds is safe for deployment pipelines
    disableConcurrentBuilds() 
  }

  // Define global environment variables
  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    BACKEND_REPO_NAME = 'agrivisionops-backend'
    FRONTEND_REPO_NAME = 'agrivisionops-frontend'
    CLUSTER_NAME = 'agrivisionops-ecs-cluster'
    BACKEND_SERVICE_NAME = 'agrivisionops-backend-service'
    FRONTEND_SERVICE_NAME = 'agrivisionops-frontend-service'
    // ECR_URI will be set dynamically in the 'AWS ECR Login' stage
    ECR_URI = '' 
  }

  stages {

    stage('Checkout Source') {
      steps {
        echo "üì¶ Cloning repository..."
        checkout scm
        sh 'git rev-parse --short HEAD'
      }
    }

    stage('AWS ECR Login') {
      steps {
        script {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "üîê Logging into ECR..."
            
            // Capture AWS Account ID directly into a Groovy variable
            def awsAccountId = sh(
              script: 'aws sts get-caller-identity --query Account --output text',
              returnStdout: true
            ).trim()
            
            // Set the global environment variable ECR_URI using Groovy
            env.ECR_URI = "${awsAccountId}.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com"
            echo "ECR URI set to: ${env.ECR_URI}"

            // Perform Docker login
            sh "aws ecr get-login-password --region ${env.AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${env.ECR_URI}"
          }
        }
      }
    }

    stage('Build & Tag Docker Images') {
      steps {
        script {
          def tag = "build-${env.BUILD_NUMBER}"
          sh """
            echo "üöß Building backend & frontend images with tag ${tag}..."

            # -------------------- BACKEND --------------------
            docker build -t ${env.BACKEND_REPO_NAME}:${tag} ./app/backend

            # Tag for ECR with specific build number
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:${tag}
            
            # Tag for ECR with 'latest' (for deployment)
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest

            # -------------------- FRONTEND --------------------
            docker build -t ${env.FRONTEND_REPO_NAME}:${tag} ./app/frontend

            # Tag for ECR with specific build number
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:${tag}
            
            # Tag for ECR with 'latest' (for deployment)
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Push Images to ECR') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "‚¨ÜÔ∏è Pushing 'latest' images to ECR..."
            docker push ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest
            docker push ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Deploy to ECS (Backend & Frontend)') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "üöÄ Deploying backend service ${env.BACKEND_SERVICE_NAME}..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.BACKEND_SERVICE_NAME} \
              --force-new-deployment

            echo "üé® Deploying frontend service ${env.FRONTEND_SERVICE_NAME}..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.FRONTEND_SERVICE_NAME} \
              --force-new-deployment
          """
        }
      }
    }

    stage('Verify Deployment') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          // This command checks the services and ensures they are active
          sh """
            echo "üîé Verifying service status..."
            aws ecs describe-services --cluster ${env.CLUSTER_NAME} \
              --services ${env.BACKEND_SERVICE_NAME} ${env.FRONTEND_SERVICE_NAME} \
              --query "services[*].{Service:serviceName,Status:status,Running:runningCount,Desired:desiredCount}" \
              --output table
          """
        }
      }
    }
  }

  post {
    success {
      echo "‚úÖ SUCCESS: Both services deployed successfully!"
    }
    failure {
      echo "‚ùå FAILURE: Check logs for details on the failed stage."
    }
    always {
      echo "üßπ Cleaning up local Docker artifacts..."
      // The '|| true' ensures the pipeline doesn't fail if the prune command fails
      sh 'docker system prune -f || true' 
    }
  }
}
