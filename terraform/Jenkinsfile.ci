pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
  }

  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    BACKEND_REPO_NAME = 'agrivisionops-backend'
    FRONTEND_REPO_NAME = 'agrivisionops-frontend'
    CLUSTER_NAME = 'agrivisionops-ecs-cluster'

    // dynamically set later
    BACKEND_SERVICE_NAME = ''
    FRONTEND_SERVICE_NAME = ''
    BACKEND_ECR_URI = ''
    FRONTEND_ECR_URI = ''
    PUBLIC_URL = ''
  }

  stages {

    /* ------------------------- CHECKOUT ------------------------- */
    stage('Checkout Source') {
      steps {
        echo "ðŸ“¦ Cloning repository..."
        checkout scm
        sh 'git rev-parse --short HEAD'
      }
    }

    /* -------------------- FETCH TERRAFORM OUTPUTS -------------------- */
    stage('Fetch Terraform Outputs') {
      steps {
        dir('terraform') {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "ðŸ“‹ Initializing Terraform backend & fetching outputs..."
            script {
              // Initialize Terraform & refresh remote state (S3 backend)
              sh '''
                terraform init -input=false -no-color
                terraform refresh -no-color
              '''

              // Capture outputs & clean formatting (trim + remove stray quotes/newlines)
              env.PUBLIC_URL            = sh(script: "terraform output -raw public_url || true", returnStdout: true).trim().replaceAll('"','')
              env.BACKEND_SERVICE_NAME  = sh(script: "terraform output -raw backend_service_name || true", returnStdout: true).trim().replaceAll('"','')
              env.FRONTEND_SERVICE_NAME = sh(script: "terraform output -raw frontend_service_name || true", returnStdout: true).trim().replaceAll('"','')
              env.BACKEND_ECR_URI       = sh(script: "terraform output -raw ecr_backend_repo_url || true", returnStdout: true).trim().replaceAll('"','')
              env.FRONTEND_ECR_URI      = sh(script: "terraform output -raw ecr_frontend_repo_url || true", returnStdout: true).trim().replaceAll('"','')

              echo "ðŸ§¾ DEBUG VALUES (raw read):"
              echo "PUBLIC_URL: '${env.PUBLIC_URL}'"
              echo "BACKEND_ECR_URI: '${env.BACKEND_ECR_URI}'"
              echo "FRONTEND_ECR_URI: '${env.FRONTEND_ECR_URI}'"

              // Safe validation using length check instead of boolean
              if (env.BACKEND_ECR_URI.length() < 10 || env.FRONTEND_ECR_URI.length() < 10) {
                error("âŒ Terraform outputs appear empty or malformed. Verify that terraform apply (Phase 1) completed successfully and remote state is accessible.")
              }

              echo "âœ… ALB/Public URL: ${env.PUBLIC_URL}"
              echo "âœ… Backend Service: ${env.BACKEND_SERVICE_NAME}"
              echo "âœ… Frontend Service: ${env.FRONTEND_SERVICE_NAME}"
              echo "âœ… Backend ECR URI: ${env.BACKEND_ECR_URI}"
              echo "âœ… Frontend ECR URI: ${env.FRONTEND_ECR_URI}"
            }
          }
        }
      }
    }

    /* --------------------------- ECR LOGIN --------------------------- */
    stage('AWS ECR Login') {
      steps {
        script {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "ðŸ” Logging into ECR..."
            def registryRoot = env.BACKEND_ECR_URI.substring(0, env.BACKEND_ECR_URI.indexOf('/'))
            env.ECR_REGISTRY_URI = registryRoot
            echo "âœ… ECR Registry URI: ${env.ECR_REGISTRY_URI}"

            // Official AWS ECR login
            sh """
              aws ecr get-login-password --region ${env.AWS_DEFAULT_REGION} | \
              docker login --username AWS --password-stdin ${env.ECR_REGISTRY_URI}
            """
          }
        }
      }
    }

    /* --------------------- BUILD & TAG DOCKER IMAGES --------------------- */
    stage('Build & Tag Docker Images') {
      steps {
        script {
          def tag = "build-${env.BUILD_NUMBER}"
          echo "ðŸš§ Building backend & frontend images with tag: ${tag}"

          sh """
            # BACKEND
            docker build -t ${env.BACKEND_REPO_NAME}:${tag} ./app/backend
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.BACKEND_ECR_URI}:${tag}
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.BACKEND_ECR_URI}:latest

            # FRONTEND
            docker build -t ${env.FRONTEND_REPO_NAME}:${tag} ./app/frontend
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.FRONTEND_ECR_URI}:${tag}
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.FRONTEND_ECR_URI}:latest
          """
        }
      }
    }

    /* --------------------------- PUSH IMAGES --------------------------- */
    stage('Push Images to ECR') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "â¬†ï¸ Pushing images to ECR..."
            docker push ${env.BACKEND_ECR_URI}:latest
            docker push ${env.FRONTEND_ECR_URI}:latest
          """
        }
      }
    }

    /* --------------------------- DEPLOY TO ECS --------------------------- */
    stage('Deploy to ECS (Backend & Frontend)') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "ðŸš€ Updating ECS services with latest images..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.BACKEND_SERVICE_NAME} \
              --force-new-deployment

            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.FRONTEND_SERVICE_NAME} \
              --force-new-deployment
          """
        }
      }
    }

    /* --------------------------- VERIFY DEPLOY --------------------------- */
    stage('Verify Deployment') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          echo "ðŸ”Ž Verifying ECS service health..."
          sh """
            aws ecs describe-services \
              --cluster ${env.CLUSTER_NAME} \
              --services ${env.BACKEND_SERVICE_NAME} ${env.FRONTEND_SERVICE_NAME} \
              --query "services[*].{Service:serviceName,Status:status,Running:runningCount,Desired:desiredCount}" \
              --output table
          """
          echo "ðŸŒ Application accessible at: ${env.PUBLIC_URL}"
        }
      }
    }
  }

  /* --------------------------- POST ACTIONS --------------------------- */
  post {
    success {
      echo "âœ… SUCCESS: ECS deployment completed!"
      echo "ðŸŒ Access your app â†’ ${env.PUBLIC_URL}"
    }
    failure {
      echo "âŒ FAILURE: Check logs carefully."
    }
    always {
      echo "ðŸ§¹ Cleaning up Docker cache..."
      sh 'docker system prune -f || true'
    }
  }
}
