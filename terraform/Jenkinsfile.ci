pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    // Disabling concurrent builds is safe for deployment pipelines
    disableConcurrentBuilds() 
  }

  // Define global environment variables. They will be populated in the 'Fetch Terraform Outputs' stage.
  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    BACKEND_REPO_NAME = 'agrivisionops-backend'
    FRONTEND_REPO_NAME = 'agrivisionops-frontend'
    CLUSTER_NAME = 'agrivisionops-ecs-cluster'
    BACKEND_SERVICE_NAME = ''
    FRONTEND_SERVICE_NAME = ''
    ECR_URI = '' 
    PUBLIC_URL = ''
  }

  stages {

    stage('Checkout Source') {
      steps {
        echo "üì¶ Cloning repository..."
        checkout scm
        sh 'git rev-parse --short HEAD'
      }
    }

    stage('Fetch Terraform Outputs') {
      steps {
        // Assume Terraform state files are stored in the 'terraform' subdirectory
        dir('terraform') {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "üìã Initializing Terraform backend & fetching outputs..."
            script {
              // Initialize Terraform safely (requires access to S3 backend state)
              sh(script: 'terraform init -input=false -no-color', returnStatus: true)

              // Capture Terraform outputs using -raw
              def alb_dns_name  = sh(script: "terraform output -raw alb_dns_name", returnStdout: true).trim()
              def backendSvc    = sh(script: "terraform output -raw backend_service_name", returnStdout: true).trim()
              def frontendSvc   = sh(script: "terraform output -raw frontend_service_name", returnStdout: true).trim()
              
              // --- CRITICAL SAFETY CHECK: Ensure outputs were found ---
              if (alb_dns_name.isEmpty() || backendSvc.isEmpty() || frontendSvc.isEmpty()) {
                  error("‚ùå Terraform outputs are empty. Ensure 'terraform apply' has run successfully in the 'terraform' directory and the state file is accessible.")
              }
              // --- END SAFETY CHECK ---

              env.PUBLIC_URL = "http://${alb_dns_name}"
              env.BACKEND_SERVICE_NAME = backendSvc
              env.FRONTEND_SERVICE_NAME = frontendSvc

              echo "‚úÖ ALB DNS: ${env.PUBLIC_URL}"
              echo "‚úÖ Backend Service: ${env.BACKEND_SERVICE_NAME}"
              echo "‚úÖ Frontend Service: ${env.FRONTEND_SERVICE_NAME}"
            }
          }
        }
      }
    }

    stage('AWS ECR Login') {
      steps {
        script {
          withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
            echo "üîê Logging into ECR..."
            
            // Initialize with empty string to prevent Groovy 'null' interpolation issues
            def awsAccountId = '' 
            
            try {
              // Capture AWS Account ID using robust sh call.
              awsAccountId = sh(
                script: 'aws sts get-caller-identity --query Account --output text',
                returnStdout: true
              ).trim()
              
              // --- DEBUG STEP: Log the raw captured value ---
              echo "üîé Captured AWS Account ID (Raw): '${awsAccountId}'"
              // ---------------------------------------------

            } catch (e) {
                // Fail immediately and explicitly if the AWS CLI call fails.
                error("‚ùå Failed to execute AWS CLI command to get Account ID. Check 'aws-creds' permissions, network access, and IAM policies. Error: ${e.getMessage()}")
            }
            
            // --- CRITICAL SAFETY CHECK: Check for empty string ---
            if (awsAccountId.isEmpty()) {
                // This catches the case where the command ran, but the output was empty (e.g., IAM permissions issue).
                error("‚ùå AWS Account ID is empty. The AWS CLI command ran but returned no output. This is usually an IAM permission issue or a networking problem preventing AWS STS API access.")
            }
            // --- END SAFETY CHECK ---

            env.ECR_URI = "${awsAccountId}.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com"
            echo "‚úÖ ECR URI set to: ${env.ECR_URI}"
            
            // Perform Docker login
            sh "aws ecr get-login-password --region ${env.AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${env.ECR_URI}"
          }
        }
      }
    }

    stage('Build & Tag Docker Images') {
      steps {
        script {
          def tag = "build-${env.BUILD_NUMBER}"
          sh """
            echo "üöß Building backend & frontend images with tag ${tag}..."

            # -------------------- BACKEND --------------------
            docker build -t ${env.BACKEND_REPO_NAME}:${tag} ./app/backend

            # Tag for ECR with specific build number
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:${tag}
            
            # Tag for ECR with 'latest' (for deployment)
            docker tag ${env.BACKEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest

            # -------------------- FRONTEND --------------------
            docker build -t ${env.FRONTEND_REPO_NAME}:${tag} ./app/frontend

            # Tag for ECR with specific build number
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:${tag}
            
            # Tag for ECR with 'latest' (for deployment)
            docker tag ${env.FRONTEND_REPO_NAME}:${tag} ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Push Images to ECR') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "‚¨ÜÔ∏è Pushing images to ECR..."
            docker push ${env.ECR_URI}/${env.BACKEND_REPO_NAME}:latest
            docker push ${env.ECR_URI}/${env.FRONTEND_REPO_NAME}:latest
          """
        }
      }
    }

    stage('Deploy to ECS (Backend & Frontend)') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          sh """
            echo "üöÄ Updating backend service..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.BACKEND_SERVICE_NAME} \
              --force-new-deployment

            echo "üé® Updating frontend service..."
            aws ecs update-service \
              --cluster ${env.CLUSTER_NAME} \
              --service ${env.FRONTEND_SERVICE_NAME} \
              --force-new-deployment
          """
        }
      }
    }

    stage('Verify Deployment') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
          echo "üîé Verifying ECS service health..."
          sh """
            aws ecs describe-services --cluster ${env.CLUSTER_NAME} \
              --services ${env.BACKEND_SERVICE_NAME} ${env.FRONTEND_SERVICE_NAME} \
              --query "services[*].{Service:serviceName,Status:status,Running:runningCount,Desired:desiredCount}" \
              --output table
          """
          echo "üåç Application accessible at: ${env.PUBLIC_URL}"
        }
      }
    }
  }

  post {
    success {
      echo "‚úÖ SUCCESS: All ECS services deployed successfully!"
      echo "üåê Access URL ‚Üí ${env.PUBLIC_URL}"
    }
    failure {
      echo "‚ùå FAILURE: Something went wrong. Check build logs carefully!"
    }
    always {
      echo "üßπ Cleaning up local Docker artifacts..."
      sh 'docker system prune -f || true'
    }
  }
}
